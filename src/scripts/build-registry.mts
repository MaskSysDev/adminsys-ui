import { promises as fs } from "node:fs"
import path from "node:path"

import { rimraf } from "rimraf"
import type { Registry } from "shadcn/schema"
import { registrySchema } from "shadcn/schema"

import { registryConfig } from "../config/registry"
import { registry } from "../registry"

const REGISTRY_PATH = path.join(process.cwd(), "src/__registry__")

/**
 * Constr√≥i os arquivos de registro do projeto, inspirados no padr√£o shadcn/ui.
 * Gera `src/__registry__/registry.autogenerated.json` e `src/__registry__/index.tsx`.
 *
 * @param registryComponent O objeto de registro validado contendo os itens e suas configura√ß√µes.
 */
export async function buildRegistry(registryComponent: Registry) {
  // Constr√≥i o conte√∫do do arquivo `index.tsx` que exporta o objeto `Index`.
  // Este objeto mapeia nomes de componentes para suas descri√ß√µes, arquivos e, para exemplos, o componente React.
  let index = `
/** biome-ignore-all lint/suspicious/noExplicitAny: Unexpected any. Specify a different type. */
// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.

import React from "react";

export const Index: Record<string, any> = {`
  for (const item of registryComponent.items) {
    if (!(Array.isArray(item.files) && item.files?.length)) {
      continue
    }

    const componentPath = `@/registry/${item.files[0].path}`

    index += `
  "${item.name}": {
    name: "${item.name}",
    description: "${item.description ?? ""}",
    type: "${item.type}",
    files: [${item.files.map((file) => {
      const filePath = `src/registry/${file.path}`
      return `{
      path: "${filePath}",
      type: "${file.type}",
    }`
    })}],${
      item.type === "registry:example"
        ? `
    component: React.lazy(() => import("${componentPath}")),
`
        : ""
    }
  },`
  }

  index += `
}`

  // Constr√≥i o conte√∫do do arquivo `registry.autogenerated.json`.
  // Este arquivo cont√©m os metadados dos componentes em formato JSON, excluindo exemplos
  // e ajustando os caminhos dos arquivos para serem relativos ao diret√≥rio `src/registry`.
  let registryJSON = JSON.stringify(
    {
      $schema: "https://ui.shadcn.com/schema/registry.json",
      name: "MaskSysDev",
      homepage: "https://adminsys-ui.vercel.app",
      items: registryComponent.items
        .filter((item) => item.type !== "registry:example")
        .map((item) => {
          return {
            ...item,
            files:
              item.files?.map((file) => {
                if (file.path.startsWith("src/")) {
                  return file
                }

                return {
                  ...file,
                  path: `src/registry/${file.path}`,
                }
              }) ?? [],
          }
        }),
    },
    null,
    2
  )

  // Substitui o placeholder `<registryBaseUrl>` pela URL base configurada.
  const registryBaseUrl = registryConfig.baseUrl
  const registryBaseUrlRegex = /<registryBaseUrl>/g
  registryJSON = registryJSON.replace(registryBaseUrlRegex, registryBaseUrl)

  // Substitui o placeholder `<baseUrl>` pela URL base configurada.
  const baseUrl = registryConfig.url
  const baseUrlRegex = /<baseUrl>/g
  registryJSON = registryJSON.replace(baseUrlRegex, baseUrl)

  // Substitui o placeholder `<author>` pelo autor configurado.
  const author = registryConfig.author
  const authorRegex = /<author>/g
  registryJSON = registryJSON.replace(authorRegex, author)

  // Substitui o placeholder `<authorUrl>` pelo URL do autor configurado.
  const authorUrl = registryConfig.authorUrl
  const authorUrlRegex = /<authorUrl>/g
  registryJSON = registryJSON.replace(authorUrlRegex, authorUrl)

  // Remove o arquivo JSON existente e escreve o novo conte√∫do.
  rimraf.sync(path.join(REGISTRY_PATH, "registry.autogenerated.json"))
  await fs.writeFile(
    path.join(REGISTRY_PATH, "registry.autogenerated.json"),
    registryJSON,
    "utf8"
  )

  // Remove o arquivo `index.tsx` existente e escreve o novo conte√∫do.
  rimraf.sync(path.join(REGISTRY_PATH, "index.tsx"))
  await fs.writeFile(path.join(REGISTRY_PATH, "index.tsx"), index, "utf8")
}

/**
 * Bloco de execu√ß√£o principal do script.
 * Valida o esquema do registro e inicia o processo de constru√ß√£o.
 * Lida com erros e exibe mensagens de sucesso/falha no console.
 */
try {
  console.log("üíΩ Building registry...")

  // Valida o objeto `registry` contra o `registrySchema`.
  const result = registrySchema.safeParse(registry)

  if (!result.success) {
    console.error(result.error)
    process.exit(1)
  }

  // Executa a fun√ß√£o de constru√ß√£o do registro com os dados validados.
  await buildRegistry(result.data)

  console.log("‚úÖ Done!")
} catch (error) {
  console.error(error)
  process.exit(1)
}
